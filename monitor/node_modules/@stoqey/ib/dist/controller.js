"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var lodash_1 = __importDefault(require("lodash"));
var command_buffer_1 = __importDefault(require("command-buffer"));
var constants_1 = __importDefault(require("./constants"));
var socket_1 = __importDefault(require("./socket"));
var incoming_1 = __importDefault(require("./incoming"));
var outgoing_1 = __importDefault(require("./outgoing"));
function Controller(ib, options) {
    if (!lodash_1.default.isPlainObject(options)) {
        options = {};
    }
    lodash_1.default.defaults(options, {
        host: constants_1.default.DEFAULT_HOST,
        port: constants_1.default.DEFAULT_PORT,
        clientId: constants_1.default.DEFAULT_CLIENT_ID,
    });
    Object.defineProperty(this, 'options', {
        get: function () {
            return options;
        }
    });
    this._ib = ib;
    this._serverVersion = null;
    this._serverConnectionTime = null;
    this._socket = new socket_1.default(this);
    this._incoming = new incoming_1.default(this);
    this._outgoing = new outgoing_1.default(this);
    this._commands = new command_buffer_1.default(function (type, data) {
        var funcName = '_' + type;
        if (lodash_1.default.has(this.constructor.prototype, funcName) && lodash_1.default.isFunction(this[funcName])) {
            this[funcName](data);
        }
        else {
            throw new Error('Missing function - ' + funcName);
        }
    }, this);
}
Controller.prototype._api = function (data) {
    var func;
    if (lodash_1.default.has(this._outgoing.constructor.prototype, data.func)) {
        func = this._outgoing[data.func];
        if (lodash_1.default.isFunction(func)) {
            return func.apply(this._outgoing, data.args);
        }
    }
    throw new Error('Unknown outgoing func - ' + data.func);
};
Controller.prototype._connect = function () {
    if (!this._socket._connected) {
        this._socket.connect();
    }
    else {
        this.emitError('Cannot connect if already connected.');
    }
};
Controller.prototype._disconnect = function () {
    if (this._socket._connected) {
        this._socket.disconnect();
    }
    else {
        this.emitError('Cannot disconnect if already disconnected.');
    }
};
Controller.prototype._send = function (data, async) {
    if (this._socket._connected) {
        this._socket.send(data, async);
    }
    else {
        this.emitError('Cannot send data when disconnected.');
    }
};
Controller.prototype._sendAsync = function (data) {
    this._send(data, true);
};
Controller.prototype.emit = function () {
    var args = Array.prototype.slice.call(arguments);
    if (args[0] === 'error' && !!args[1] && args[1].message) {
        args[1] = args[1].message;
    }
    this._ib.emit.apply(this._ib, arguments);
    var eventOfArgs = args[0];
    var argsOfArgs = args.slice(1);
    if (!lodash_1.default.includes(['connected', 'disconnected', 'error', 'received', 'sent', 'server'], eventOfArgs)) {
        this._ib.emit('result', eventOfArgs, argsOfArgs);
    }
    this._ib.emit('all', eventOfArgs, argsOfArgs);
};
Controller.prototype.emitError = function (errMsg, data) {
    this.emit('error', new Error(errMsg), data);
};
Controller.prototype.pause = function () {
    this._commands.pause.apply(this._commands, arguments);
};
Controller.prototype.resume = function () {
    this._commands.resume.apply(this._commands, arguments);
};
Controller.prototype.run = function () {
    this._commands.run.apply(this._commands, arguments);
};
Controller.prototype.schedule = function () {
    this._commands.schedule.apply(this._commands, arguments);
};
module.exports = Controller;
//# sourceMappingURL=controller.js.map