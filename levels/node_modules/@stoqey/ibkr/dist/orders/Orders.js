"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var isEmpty_1 = __importDefault(require("lodash/isEmpty"));
var compact_1 = __importDefault(require("lodash/compact"));
var timeout_manager_1 = require("@stoqey/timeout-manager");
var events_1 = require("../events");
var IBKRConnection_1 = __importDefault(require("../connection/IBKRConnection"));
var portfolios_1 = require("../portfolios");
var log_1 = require("../log");
var ibkrEvents = events_1.IbkrEvents.Instance;
var Orders = /** @class */ (function () {
    function Orders() {
        var _this = this;
        this.ib = null;
        // StockOrders
        this.tickerId = 0;
        this.processing = false;
        /**
         * Orders to be taken from nextValidId
         * These are always deleted after order is submitted to IB
         */
        this.stockOrders = [];
        this.timeoutRetries = {};
        /**
         * A ledger of orders that are being executed,
         * This is to avoid duplicate orders
         * @unique
         * new order overrides old one
         * only filled, canceled, error orders can be overridden
         */
        this.symbolsTickerOrder = {};
        /**
         * Redundant orderIdNext recorded
         */
        this.orderIdNext = null;
        // OPEN ORDERS
        this.openOrders = {};
        this.receivedOrders = false; // stopper
        /**
         * init
         */
        this.init = function () { return __awaiter(_this, void 0, void 0, function () {
            var self, ib;
            var _this = this;
            return __generator(this, function (_a) {
                self = this;
                if (!self.ib) {
                    ib = IBKRConnection_1.default.Instance.getIBKR();
                    self.ib = ib;
                    ib.on('openOrderEnd', function () {
                        // Initialise OrderTrader
                        // OrderTrade.Instance.init();
                        var openOrders = Object.keys(self.openOrders).map(function (key) { return self.openOrders[key]; });
                        events_1.publishDataToTopic({
                            topic: events_1.IBKREVENTS.OPEN_ORDERS,
                            data: openOrders,
                        });
                    });
                    ib.on('orderStatus', function (id, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld) {
                        var currentOrder = self.openOrders[id];
                        var orderStatus = {
                            status: status,
                            filled: filled,
                            remaining: remaining,
                            avgFillPrice: avgFillPrice,
                            permId: permId,
                            parentId: parentId,
                            lastFillPrice: lastFillPrice,
                            clientId: clientId,
                            whyHeld: whyHeld,
                        };
                        events_1.publishDataToTopic({
                            topic: events_1.IBKREVENTS.ORDER_STATUS,
                            data: {
                                order: currentOrder,
                                orderStatus: orderStatus,
                            },
                        });
                        log_1.verbose("Orders > orderStatus " + (currentOrder && currentOrder.symbol), JSON.stringify({
                            id: id,
                            status: status,
                            filled: filled,
                            remaining: remaining,
                            symbol: currentOrder && currentOrder.symbol,
                        }));
                    });
                    ib.on('openOrder', function (orderId, contract, order, orderState) {
                        var _a;
                        // 1. Update OpenOrders
                        // Orders that need to be filled
                        // -----------------------------------------------------------------------------------
                        self.receivedOrders = true;
                        var openOrders = self.openOrders;
                        self.openOrders = __assign(__assign({}, openOrders), (_a = {}, _a[orderId] = __assign(__assign(__assign(__assign({}, ((openOrders && openOrders[orderId]) || null)), { 
                            // OrderId + orderState
                            orderId: orderId,
                            orderState: orderState }), order), contract), _a));
                        //  Delete order from openOrders list
                        if (orderState.status === 'Filled') {
                            log_1.log("Filled -----> DELETE FROM OPEN ORDERS -------> symbol=" + (contract && contract.symbol));
                            delete self.openOrders[orderId];
                        }
                        //  Delete order from openOrders list
                        if (['PendingCancel', 'Cancelled', 'ApiCancelled'].includes(orderState.status)) {
                            log_1.log(orderState.status + " -----> DELETE FROM OPEN ORDERS -------> " + (contract && contract.symbol));
                            delete self.openOrders[orderId];
                        }
                        var openOrdersArr = Object.keys(self.openOrders).map(function (key) { return self.openOrders[key]; });
                        log_1.log("OPEN ORDERS " + (openOrdersArr && openOrdersArr.length));
                        // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                        // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                        // 2. Update OrderStocks
                        // Orders requests to send to transmit
                        // Using ticker Ids
                        // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                        var allTickerOrder = Object.keys(self.symbolsTickerOrder).map(function (key) { return self.symbolsTickerOrder[key]; });
                        var thisOrderTicker = allTickerOrder.find(function (tickerOrder) { return tickerOrder.tickerId === orderId; });
                        // Add permId to orderTickObject
                        if (!isEmpty_1.default(thisOrderTicker)) {
                            // update this symbolTickerOrder
                            self.symbolsTickerOrder[thisOrderTicker.symbol] = __assign(__assign({}, (self.symbolsTickerOrder[thisOrderTicker.symbol] || null)), { orderPermId: order.permId, symbol: thisOrderTicker.symbol, orderStatus: orderState.status });
                            var updatedSymbolTicker = self.symbolsTickerOrder[thisOrderTicker.symbol];
                            // create sale if order is filled
                            if (orderState.status === 'Filled') {
                                // Order is filled we can record it
                                // Check if we can create new trade
                                // on if stockOrderRequest is present
                                // that.symbolsTickerOrder[thisOrderTicker.symbol]
                                if (!isEmpty_1.default(updatedSymbolTicker.stockOrderRequest)) {
                                    var stockOrderRequest = updatedSymbolTicker.stockOrderRequest;
                                    var exitTrade = stockOrderRequest.exitTrade, exitParams = stockOrderRequest.exitParams, symbol = stockOrderRequest.symbol, capital = stockOrderRequest.capital;
                                    var dataSaleSymbolOrder = __assign(__assign(__assign({}, order), contract), { orderState: orderState,
                                        orderId: orderId });
                                    if (exitTrade) {
                                        var exitPrice = exitParams.exitPrice, exitTime = exitParams.exitTime, entryTime = exitParams.entryTime, entryPrice = exitParams.entryPrice;
                                        // If this trade is for exiting then record the sale
                                        // create sale now
                                        var newSale = {
                                            capital: capital,
                                            exitPrice: exitPrice,
                                            exitTime: exitTime,
                                            entryTime: entryTime,
                                            entryPrice: entryPrice,
                                            symbol: symbol,
                                            profit: entryPrice - exitPrice,
                                        };
                                        log_1.log("AccountOrderStock.openOrder", "FILLED, TO CREATE SALE -> " + contract.symbol + " " + order.action + " " + order.totalQuantity + "  " + orderState.status);
                                        return events_1.publishDataToTopic({
                                            topic: events_1.IBKREVENTS.ORDER_FILLED,
                                            data: { sale: newSale, order: dataSaleSymbolOrder },
                                        });
                                    }
                                    log_1.log("AccountOrderStock.openOrder", "FILLED, but no sale created -> " + contract.symbol + " " + order.action + " " + order.totalQuantity + "  " + orderState.status);
                                    events_1.publishDataToTopic({
                                        topic: events_1.IBKREVENTS.ORDER_FILLED,
                                        data: { sale: null, order: dataSaleSymbolOrder },
                                    });
                                }
                            }
                        }
                    });
                    // placeOrder event
                    ibkrEvents.on(events_1.IBKREVENTS.PLACE_ORDER, function (_a) {
                        var stockOrder = _a.stockOrder;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, self.placeOrder(stockOrder)];
                                    case 1:
                                        _b.sent();
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                }
                return [2 /*return*/];
            });
        }); };
        this.getOpenOrders = function (timeout) { return __awaiter(_this, void 0, void 0, function () {
            var self, openedOrders;
            return __generator(this, function (_a) {
                self = this;
                openedOrders = {};
                return [2 /*return*/, new Promise(function (resolve) {
                        var done = false;
                        // listen for account summary
                        var handleOpenOrders = function (ordersData) {
                            if (!done) {
                                self.ib.off('openOrder', handleOpenOrders);
                                done = true;
                                resolve(ordersData);
                            }
                        };
                        self.ib.once('openOrderEnd', function () {
                            var openOrders = Object.keys(openedOrders).map(function (key) { return openedOrders[key]; });
                            handleOpenOrders(openOrders);
                        });
                        self.ib.on('openOrder', function (orderId, contract, order, orderState) {
                            var _a;
                            // Only check pending orders
                            if (['PendingSubmit', 'PreSubmitted', 'Submitted'].includes(orderState && orderState.status)) {
                                openedOrders = __assign(__assign({}, openedOrders), (_a = {}, _a[orderId] = __assign(__assign(__assign(__assign({}, ((openedOrders && openedOrders[orderId]) || null)), { 
                                    // OrderId + orderState
                                    orderId: orderId,
                                    orderState: orderState }), order), contract), _a));
                            }
                        });
                        self.ib.reqAllOpenOrders(); // refresh orders
                        return setTimeout(handleOpenOrders, timeout || 6000);
                    })];
            });
        }); };
        this.isActive = function () {
            return _this.receivedOrders;
        };
        /**
         * Place Order
         * Order is added to queue if is already processing one order
         * @stockOrder
         * @options ? {}
         * @when Until IBKR releases a new OrderId, then order is placed and process can pick other orders
         */
        this.placeOrder = function (stockOrder, options) { return __awaiter(_this, void 0, void 0, function () {
            function placingOrderNow() {
                if (isEmpty_1.default(stockOrder.symbol)) {
                    return erroredOut(new Error('Please enter order'));
                }
                self.stockOrders = __spreadArrays(self.stockOrders, [stockOrder]);
                self.ib.reqIds(++self.orderIdNext);
                log_1.verbose('placingOrderNow', "Order > placeOrder -> tickerId=" + self.tickerId + " symbol=" + stockOrder.symbol);
            }
            function run() {
                return __awaiter(this, void 0, void 0, function () {
                    var canProceed, handleRecursive_1, handlerId;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, checkPending()];
                            case 1:
                                canProceed = _a.sent();
                                if (canProceed === true) {
                                    // can proceed
                                    // 1. Processing, or recursive
                                    if (self.processing) {
                                        handleRecursive_1 = setInterval(function () {
                                            console.log('retry in --------------------->', symbol);
                                            self.placeOrder(stockOrder);
                                        }, 2000);
                                        handlerId = timeout_manager_1.intervalCollection.get(handleRecursive_1);
                                        // save the symbol with it's timeout
                                        self.timeoutRetries[stockOrder.symbol] = compact_1.default(__spreadArrays((self.timeoutRetries[stockOrder.symbol] || []), [
                                            handlerId && handlerId.uuid,
                                        ]));
                                        setTimeout(function () {
                                            timeout_manager_1.intervalCollection.remove(handleRecursive_1);
                                        }, numberOfRetries * retryDelayTime);
                                        return [2 /*return*/];
                                    }
                                    // Clear all by this symbol
                                    (self.timeoutRetries[stockOrder.symbol] || []).forEach(function (uuid) {
                                        timeout_manager_1.intervalCollection.removeByUuid(uuid);
                                    });
                                    // Start -----------------------------
                                    self.processing = true;
                                    ib.on('nextValidId', handleOrderIdNext); // start envs
                                    return [2 /*return*/, placingOrderNow()];
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            }
            var self, ib, exitTrade, symbol, numberOfRetries, retryDelayTime, success, erroredOut, checkPending, handleOrderIdNext;
            var _this = this;
            return __generator(this, function (_a) {
                self = this;
                ib = self.ib;
                exitTrade = stockOrder.exitTrade, symbol = stockOrder.symbol;
                numberOfRetries = (options && options.retryCounts) || 3;
                retryDelayTime = (options && options.retryTime) || 2000;
                success = function () {
                    ib.off('nextValidId', handleOrderIdNext);
                    self.processing = false; // reset processing
                    return;
                };
                erroredOut = function (error) {
                    ib.off('nextValidId', handleOrderIdNext);
                    self.processing = false; // reset processing
                    return;
                };
                checkPending = function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderSize, pendingOrders, pendingOrderStatus, isPending, checkExistingOrders, findMatchingAction, checkExistingPositions, foundExistingPortfolios;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                orderSize = stockOrder.size;
                                if (Number.isNaN(orderSize)) {
                                    log_1.log('placingOrderNow.checkPending', "*********************** orderSize is NaN size=" + orderSize + " action=" + stockOrder.action + " symbol=" + symbol);
                                    return [2 /*return*/, erroredOut()];
                                }
                                pendingOrders = self.symbolsTickerOrder[symbol];
                                pendingOrderStatus = pendingOrders && pendingOrders.orderStatus;
                                isPending = ['PreSubmitted', 'Submitted', 'PendingSubmit'].includes(pendingOrderStatus);
                                if (isPending) {
                                    log_1.log('placingOrderNow', "*********************** Order is already being processed for " + stockOrder.action + " symbol=" + symbol + " pendingOrderStatus=" + (pendingOrderStatus || 'NONE') + " isPending=" + isPending);
                                    return [2 /*return*/, erroredOut()];
                                }
                                return [4 /*yield*/, self.getOpenOrders()];
                            case 1:
                                checkExistingOrders = _a.sent();
                                log_1.log('placingOrderNow', "Existing orders in queue -> " + checkExistingOrders.map(function (i) { return i.symbol; }));
                                if (!isEmpty_1.default(checkExistingOrders)) {
                                    findMatchingAction = checkExistingOrders.filter(function (exi) { return exi.action === stockOrder.action && exi.symbol === stockOrder.symbol; });
                                    if (!isEmpty_1.default(findMatchingAction)) {
                                        log_1.log('placingOrderNow', "Order already exist for " + stockOrder.action + ", " + findMatchingAction[0].symbol + " ->  @" + stockOrder.parameters[0]);
                                        return [2 /*return*/, erroredOut()];
                                    }
                                }
                                return [4 /*yield*/, portfolios_1.Portfolios.Instance.getPortfolios()];
                            case 2:
                                checkExistingPositions = _a.sent();
                                checkExistingPositions = !isEmpty_1.default(checkExistingPositions) ? checkExistingPositions : [];
                                log_1.verbose('placingOrderNow', "Existing portfolios -> " + JSON.stringify(checkExistingPositions && checkExistingPositions.map(function (i) { return i.symbol; })));
                                foundExistingPortfolios = !isEmpty_1.default(checkExistingPositions)
                                    ? checkExistingPositions.filter(function (exi) { return exi.symbol === stockOrder.symbol; })
                                    : [];
                                log_1.verbose('placingOrderNow', "foundExistingPortfolios -> " + JSON.stringify(foundExistingPortfolios.map(function (i) { return i.symbol; })));
                                if (!isEmpty_1.default(foundExistingPortfolios)) {
                                    // Only if this is not exit
                                    if (!exitTrade) {
                                        log_1.log('placingOrderNow', "*********************** Portfolio already exist and has position for " + stockOrder.action + ", order=" + JSON.stringify(foundExistingPortfolios.map(function (i) { return i.symbol; })));
                                        return [2 /*return*/, erroredOut()];
                                    }
                                    // Else existing trades are allowed
                                }
                                return [2 /*return*/, true];
                        }
                    });
                }); };
                handleOrderIdNext = function (orderIdNext) {
                    var tickerToUse = ++orderIdNext;
                    var currentOrders = self.stockOrders;
                    if (isEmpty_1.default(currentOrders)) {
                        log_1.log('handleOrderIdNext', "Stock Orders are empty");
                        return erroredOut();
                    }
                    // get order by it's tickerId
                    var stockOrder = self.stockOrders.shift();
                    if (isEmpty_1.default(stockOrder)) {
                        log_1.log('handleOrderIdNext', "First Stock Orders Item is empty");
                        return erroredOut();
                    }
                    var symbol = stockOrder.symbol, size = stockOrder.size;
                    // eslint-disable-next-line @typescript-eslint/ban-types
                    var orderCommand = ib.order[stockOrder.type];
                    var args = stockOrder.parameters;
                    if (isEmpty_1.default(args)) {
                        log_1.log('handleOrderIdNext', "Arguments cannot be null");
                        return erroredOut();
                    }
                    // Just save tickerId and stockOrder
                    self.symbolsTickerOrder[symbol] = __assign(__assign({}, (self.symbolsTickerOrder[symbol] || null)), { tickerId: tickerToUse, symbol: symbol, orderStatus: 'PendingSubmit', stockOrderRequest: stockOrder });
                    // Place order
                    ib.placeOrder(tickerToUse, ib.contract.stock(stockOrder.symbol), orderCommand.apply(void 0, __spreadArrays([stockOrder.action], args)));
                    // self.orderIdNext = tickerToUse;
                    self.tickerId = tickerToUse;
                    ib.reqAllOpenOrders(); // refresh orders
                    log_1.log('handleOrderIdNext', "Placing order for ... tickerToUse=" + tickerToUse + " orderIdNext=" + orderIdNext + " tickerId=" + self.tickerId + " symbol=" + symbol + " size=" + size);
                    return success();
                };
                run();
                return [2 /*return*/];
            });
        }); };
        var self = this;
        // only when connected createSale
        ibkrEvents.on(events_1.IBKREVENTS.CONNECTED, function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                self.init();
                return [2 /*return*/];
            });
        }); });
        ibkrEvents.emit(events_1.IBKREVENTS.PING); // ping connection
    }
    Object.defineProperty(Orders, "Instance", {
        get: function () {
            return this._instance || (this._instance = new this());
        },
        enumerable: true,
        configurable: true
    });
    return Orders;
}());
exports.Orders = Orders;
exports.default = Orders;
//# sourceMappingURL=Orders.js.map