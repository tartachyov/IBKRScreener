{"version":3,"file":"Orders.js","sourceRoot":"","sources":["../../src/orders/Orders.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,2DAAqC;AACrC,2DAAqC;AACrC,2DAA2D;AAW3D,oCAAqE;AACrE,gFAA0D;AAE1D,4CAAyC;AACzC,8BAAoC;AAEpC,IAAM,UAAU,GAAG,mBAAU,CAAC,QAAQ,CAAC;AAavC;IAuCI;QAAA,iBASC;QA/CD,OAAE,GAAO,IAAI,CAAC;QAEd,cAAc;QACd,aAAQ,GAAG,CAAC,CAAC;QACb,eAAU,GAAG,KAAK,CAAC;QAEnB;;;WAGG;QACH,gBAAW,GAAiB,EAAE,CAAC;QAE/B,mBAAc,GAA4B,EAAE,CAAC;QAE7C;;;;;;WAMG;QACH,uBAAkB,GAAqC,EAAE,CAAC;QAE1D;;WAEG;QACH,gBAAW,GAAW,IAAI,CAAC;QAE3B,cAAc;QACP,eAAU,GAAqC,EAAE,CAAC;QAClD,mBAAc,GAAG,KAAK,CAAC,CAAC,UAAU;QAmBzC;;WAEG;QACI,SAAI,GAAG;;;;gBACJ,IAAI,GAAG,IAAI,CAAC;gBAElB,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE;oBACJ,EAAE,GAAG,wBAAc,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;oBAC7C,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;oBAEb,EAAE,CAAC,EAAE,CAAC,cAAc,EAAE;wBAClB,yBAAyB;wBACzB,8BAA8B;wBAE9B,IAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,UAAC,GAAG,IAAK,OAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAApB,CAAoB,CAAC,CAAC;wBAEnF,2BAAkB,CAAC;4BACf,KAAK,EAAE,mBAAU,CAAC,WAAW;4BAC7B,IAAI,EAAE,UAAU;yBACnB,CAAC,CAAC;oBACP,CAAC,CAAC,CAAC;oBAEH,EAAE,CAAC,EAAE,CACD,aAAa,EACb,UACI,EAAE,EACF,MAAM,EACN,MAAM,EACN,SAAS,EACT,YAAY,EACZ,MAAM,EACN,QAAQ,EACR,aAAa,EACb,QAAQ,EACR,OAAO;wBAEP,IAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;wBAEzC,IAAM,WAAW,GAAgB;4BAC7B,MAAM,QAAA;4BACN,MAAM,QAAA;4BACN,SAAS,WAAA;4BACT,YAAY,cAAA;4BACZ,MAAM,QAAA;4BACN,QAAQ,UAAA;4BACR,aAAa,eAAA;4BACb,QAAQ,UAAA;4BACR,OAAO,SAAA;yBACV,CAAC;wBAEF,2BAAkB,CAAC;4BACf,KAAK,EAAE,mBAAU,CAAC,YAAY;4BAC9B,IAAI,EAAE;gCACF,KAAK,EAAE,YAAY;gCACnB,WAAW,aAAA;6BACd;yBACJ,CAAC,CAAC;wBAEH,aAAO,CACH,2BAAwB,YAAY,IAAI,YAAY,CAAC,MAAM,CAAE,EAC7D,IAAI,CAAC,SAAS,CAAC;4BACX,EAAE,IAAA;4BACF,MAAM,QAAA;4BACN,MAAM,QAAA;4BACN,SAAS,WAAA;4BACT,MAAM,EAAE,YAAY,IAAI,YAAY,CAAC,MAAM;yBAC9C,CAAC,CACL,CAAC;oBACN,CAAC,CACJ,CAAC;oBAEF,EAAE,CAAC,EAAE,CAAC,WAAW,EAAE,UAAU,OAAO,EAAE,QAAQ,EAAE,KAAY,EAAE,UAAsB;;wBAChF,uBAAuB;wBACvB,gCAAgC;wBAChC,sFAAsF;wBACtF,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;wBAE3B,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;wBAEnC,IAAI,CAAC,UAAU,yBACR,UAAU,gBACZ,OAAO,4CACD,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC;4BAEhD,uBAAuB;4BACvB,OAAO,SAAA;4BACP,UAAU,YAAA,KAGP,KAAK,GAEL,QAAQ,OAElB,CAAC;wBACF,qCAAqC;wBACrC,IAAI,UAAU,CAAC,MAAM,KAAK,QAAQ,EAAE;4BAChC,SAAG,CACC,4DACI,QAAQ,IAAI,QAAQ,CAAC,MAAM,CAC7B,CACL,CAAC;4BACF,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;yBACnC;wBAED,qCAAqC;wBACrC,IAAI,CAAC,eAAe,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;4BAC5E,SAAG,CACI,UAAU,CAAC,MAAM,kDAChB,QAAQ,IAAI,QAAQ,CAAC,MAAM,CAC7B,CACL,CAAC;4BACF,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;yBACnC;wBAED,IAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAClD,UAAC,GAAG,IAAK,OAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAApB,CAAoB,CAChC,CAAC;wBACF,SAAG,CAAC,kBAAe,aAAa,IAAI,aAAa,CAAC,MAAM,CAAE,CAAC,CAAC;wBAC5D,8LAA8L;wBAC9L,8LAA8L;wBAE9L,wBAAwB;wBACxB,sCAAsC;wBACtC,mBAAmB;wBACnB,8LAA8L;wBAC9L,IAAM,cAAc,GAAwB,MAAM,CAAC,IAAI,CACnD,IAAI,CAAC,kBAAkB,CAC1B,CAAC,GAAG,CAAC,UAAC,GAAG,IAAK,OAAA,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAA5B,CAA4B,CAAC,CAAC;wBAE7C,IAAM,eAAe,GAAG,cAAc,CAAC,IAAI,CACvC,UAAC,WAAW,IAAK,OAAA,WAAW,CAAC,QAAQ,KAAK,OAAO,EAAhC,CAAgC,CACpD,CAAC;wBAEF,gCAAgC;wBAChC,IAAI,CAAC,iBAAO,CAAC,eAAe,CAAC,EAAE;4BAC3B,gCAAgC;4BAChC,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,MAAM,CAAC,yBACxC,CAAC,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,KAC5D,WAAW,EAAE,KAAK,CAAC,MAAM,EACzB,MAAM,EAAE,eAAe,CAAC,MAAM,EAC9B,WAAW,EAAE,UAAU,CAAC,MAAM,GACjC,CAAC;4BAEF,IAAM,mBAAmB,GAAG,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;4BAE5E,iCAAiC;4BACjC,IAAI,UAAU,CAAC,MAAM,KAAK,QAAQ,EAAE;gCAChC,mCAAmC;gCACnC,mCAAmC;gCACnC,qCAAqC;gCACrC,kDAAkD;gCAClD,IAAI,CAAC,iBAAO,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,EAAE;oCAC1C,IAAA,yDAAiB,CAAwB;oCACzC,IAAA,uCAAS,EAAE,yCAAU,EAAE,iCAAM,EAAE,mCAAO,CAAsB;oCAEnE,IAAM,mBAAmB,kCAClB,KAAK,GACL,QAAQ,KACX,UAAU,YAAA;wCACV,OAAO,SAAA,GACV,CAAC;oCAEF,IAAI,SAAS,EAAE;wCACJ,IAAA,gCAAS,EAAE,8BAAQ,EAAE,gCAAS,EAAE,kCAAU,CAAe;wCAChE,oDAAoD;wCACpD,kBAAkB;wCAClB,IAAM,OAAO,GAAe;4CACxB,OAAO,SAAA;4CACP,SAAS,WAAA;4CACT,QAAQ,UAAA;4CACR,SAAS,WAAA;4CACT,UAAU,YAAA;4CACV,MAAM,QAAA;4CACN,MAAM,EAAE,UAAU,GAAG,SAAS;yCACjC,CAAC;wCAEF,SAAG,CACC,6BAA6B,EAC7B,+BAA6B,QAAQ,CAAC,MAAM,SAAI,KAAK,CAAC,MAAM,SAAI,KAAK,CAAC,aAAa,UAAK,UAAU,CAAC,MAAQ,CAC9G,CAAC;wCAEF,OAAO,2BAAkB,CAAC;4CACtB,KAAK,EAAE,mBAAU,CAAC,YAAY;4CAC9B,IAAI,EAAE,EAAC,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,mBAAmB,EAAC;yCACpD,CAAC,CAAC;qCACN;oCAED,SAAG,CACC,6BAA6B,EAC7B,oCAAkC,QAAQ,CAAC,MAAM,SAAI,KAAK,CAAC,MAAM,SAAI,KAAK,CAAC,aAAa,UAAK,UAAU,CAAC,MAAQ,CACnH,CAAC;oCAEF,2BAAkB,CAAC;wCACf,KAAK,EAAE,mBAAU,CAAC,YAAY;wCAC9B,IAAI,EAAE,EAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,mBAAmB,EAAC;qCACjD,CAAC,CAAC;iCACN;6BACJ;yBACJ;oBACL,CAAC,CAAC,CAAC;oBAEH,mBAAmB;oBACnB,UAAU,CAAC,EAAE,CACT,mBAAU,CAAC,WAAW,EACtB,UAAO,EAAsC;4BAArC,0BAAU;;;;4CACd,qBAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,EAAA;;wCAAjC,SAAiC,CAAC;;;;;qBACrC,CACJ,CAAC;iBACL;;;aACJ,CAAC;QAEK,kBAAa,GAAG,UAAO,OAAgB;;;gBACpC,IAAI,GAAG,IAAI,CAAC;gBAEd,YAAY,GAAG,EAAE,CAAC;gBAEtB,sBAAO,IAAI,OAAO,CAAC,UAAC,OAAO;wBACvB,IAAI,IAAI,GAAG,KAAK,CAAC;wBAEjB,6BAA6B;wBAC7B,IAAM,gBAAgB,GAAG,UAAC,UAAU;4BAChC,IAAI,CAAC,IAAI,EAAE;gCACP,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,WAAW,EAAE,gBAAgB,CAAC,CAAC;gCAC3C,IAAI,GAAG,IAAI,CAAC;gCACZ,OAAO,CAAC,UAAU,CAAC,CAAC;6BACvB;wBACL,CAAC,CAAC;wBAEF,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE;4BACzB,IAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,UAAC,GAAG,IAAK,OAAA,YAAY,CAAC,GAAG,CAAC,EAAjB,CAAiB,CAAC,CAAC;4BAC7E,gBAAgB,CAAC,UAAU,CAAC,CAAC;wBACjC,CAAC,CAAC,CAAC;wBAEH,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,WAAW,EAAE,UACpB,OAAO,EACP,QAAQ,EACR,KAAY,EACZ,UAAsB;;4BAEtB,4BAA4B;4BAC5B,IACI,CAAC,eAAe,EAAE,cAAc,EAAE,WAAW,CAAC,CAAC,QAAQ,CACnD,UAAU,IAAI,UAAU,CAAC,MAAM,CAClC,EACH;gCACE,YAAY,yBACL,YAAY,gBACd,OAAO,4CACD,CAAC,CAAC,YAAY,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC;oCAEpD,uBAAuB;oCACvB,OAAO,SAAA;oCACP,UAAU,YAAA,KAGP,KAAK,GAEL,QAAQ,OAElB,CAAC;6BACL;wBACL,CAAC,CAAC,CAAC;wBAEH,IAAI,CAAC,EAAE,CAAC,gBAAgB,EAAE,CAAC,CAAC,iBAAiB;wBAE7C,OAAO,UAAU,CAAC,gBAAgB,EAAE,OAAO,IAAI,IAAI,CAAC,CAAC;oBACzD,CAAC,CAAC,EAAC;;aACN,CAAC;QAEK,aAAQ,GAAG;YACd,OAAO,KAAI,CAAC,cAAc,CAAC;QAC/B,CAAC,CAAC;QAEF;;;;;;WAMG;QACI,eAAU,GAAG,UAChB,UAAsB,EACtB,OAAoD;YA8KpD,SAAS,eAAe;gBACpB,IAAI,iBAAO,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;oBAC5B,OAAO,UAAU,CAAC,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAC;iBACtD;gBAED,IAAI,CAAC,WAAW,kBAAO,IAAI,CAAC,WAAW,GAAE,UAAU,EAAC,CAAC;gBACrD,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;gBACnC,aAAO,CACH,iBAAiB,EACjB,oCAAkC,IAAI,CAAC,QAAQ,gBAAW,UAAU,CAAC,MAAQ,CAChF,CAAC;YACN,CAAC;YAED,SAAe,GAAG;;;;;oCACK,qBAAM,YAAY,EAAE,EAAA;;gCAAjC,UAAU,GAAG,SAAoB;gCAEvC,IAAI,UAAU,KAAK,IAAI,EAAE;oCACrB,cAAc;oCACd,8BAA8B;oCAC9B,IAAI,IAAI,CAAC,UAAU,EAAE;wCACX,oBAAkB,WAAW,CAAC;4CAChC,OAAO,CAAC,GAAG,CAAC,iCAAiC,EAAE,MAAM,CAAC,CAAC;4CACvD,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;wCAChC,CAAC,EAAE,IAAI,CAAC,CAAC;wCAEH,SAAS,GAAG,oCAAkB,CAAC,GAAG,CAAC,iBAAe,CAAC,CAAC;wCAE1D,oCAAoC;wCACpC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,iBAAO,gBACzC,CAAC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;4CACjD,SAAS,IAAI,SAAS,CAAC,IAAI;2CAC7B,CAAC;wCAEH,UAAU,CAAC;4CACP,oCAAkB,CAAC,MAAM,CAAC,iBAAe,CAAC,CAAC;wCAC/C,CAAC,EAAE,eAAe,GAAG,cAAc,CAAC,CAAC;wCACrC,sBAAO;qCACV;oCAED,2BAA2B;oCAC3B,CAAC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,UAAC,IAAI;wCACxD,oCAAkB,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;oCAC1C,CAAC,CAAC,CAAC;oCAEH,sCAAsC;oCACtC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;oCAEvB,EAAE,CAAC,EAAE,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC,CAAC,aAAa;oCACtD,sBAAO,eAAe,EAAE,EAAC;iCAC5B;;;;;aACJ;;;;gBA9NK,IAAI,GAAG,IAAI,CAAC;gBACZ,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC;gBAEZ,SAAS,GAAY,UAAU,UAAtB,EAAE,MAAM,GAAI,UAAU,OAAd,CAAe;gBAEjC,eAAe,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBACxD,cAAc,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC;gBAExD,OAAO,GAAG;oBACZ,EAAE,CAAC,GAAG,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;oBACzC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC,mBAAmB;oBAC5C,OAAO;gBACX,CAAC,CAAC;gBAGI,UAAU,GAAG,UAAC,KAAa;oBAC7B,EAAE,CAAC,GAAG,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;oBACzC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC,mBAAmB;oBAC5C,OAAO;gBACX,CAAC,CAAC;gBAEI,YAAY,GAAG;;;;;gCAEX,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC;gCAElC,IAAI,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;oCACzB,SAAG,CACC,8BAA8B,EAC9B,mDAAiD,SAAS,gBAAW,UAAU,CAAC,MAAM,gBAAW,MAAQ,CAC5G,CAAC;oCACF,sBAAO,UAAU,EAAE,EAAC;iCACvB;gCAIK,aAAa,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;gCAChD,kBAAkB,GAAG,aAAa,IAAI,aAAa,CAAC,WAAW,CAAC;gCAChE,SAAS,GAAG,CAAC,cAAc,EAAE,WAAW,EAAE,eAAe,CAAC,CAAC,QAAQ,CACrE,kBAAkB,CACrB,CAAC;gCAEF,IAAI,SAAS,EAAE;oCACX,SAAG,CACC,iBAAiB,EACjB,kEACI,UAAU,CAAC,MAAM,gBACV,MAAM,6BACb,kBAAkB,IAAI,MAAM,oBAClB,SAAW,CAC5B,CAAC;oCACF,sBAAO,UAAU,EAAE,EAAC;iCACvB;gCAG2B,qBAAM,IAAI,CAAC,aAAa,EAAE,EAAA;;gCAAhD,mBAAmB,GAAG,SAA0B;gCAEtD,SAAG,CACC,iBAAiB,EACjB,iCAA+B,mBAAmB,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAG,CAC5E,CAAC;gCAEF,IAAI,CAAC,iBAAO,CAAC,mBAAmB,CAAC,EAAE;oCAEzB,kBAAkB,GAAG,mBAAmB,CAAC,MAAM,CACjD,UAAC,GAAG,IAAK,OAAA,GAAG,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,IAAI,GAAG,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,EAApE,CAAoE,CAChF,CAAC;oCAEF,IAAI,CAAC,iBAAO,CAAC,kBAAkB,CAAC,EAAE;wCAC9B,SAAG,CACC,iBAAiB,EACjB,6BAA2B,UAAU,CAAC,MAAM,UAAK,kBAAkB,CAAC,CAAC,CAAC,CAAC,MAAM,cAAS,UAAU,CAAC,UAAU,CAAC,CAAC,CAAG,CACnH,CAAC;wCACF,sBAAO,UAAU,EAAE,EAAC;qCACvB;iCACJ;gCAG4B,qBAAM,uBAAU,CAAC,QAAQ,CAAC,aAAa,EAAE,EAAA;;gCAAlE,sBAAsB,GAAG,SAAyC;gCACtE,sBAAsB,GAAG,CAAC,iBAAO,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC,EAAE,CAAC;gCAExF,aAAO,CACH,iBAAiB,EACjB,4BAA0B,IAAI,CAAC,SAAS,CACpC,sBAAsB,IAAI,sBAAsB,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAC,CACtE,CACN,CAAC;gCAEI,uBAAuB,GAAG,CAAC,iBAAO,CAAC,sBAAsB,CAAC;oCAC5D,CAAC,CAAC,sBAAsB,CAAC,MAAM,CAAC,UAAC,GAAG,IAAK,OAAA,GAAG,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,EAAhC,CAAgC,CAAC;oCAC1E,CAAC,CAAC,EAAE,CAAC;gCAET,aAAO,CACH,iBAAiB,EACjB,gCAA8B,IAAI,CAAC,SAAS,CACxC,uBAAuB,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAC,CAC7C,CACN,CAAC;gCAEF,IAAI,CAAC,iBAAO,CAAC,uBAAuB,CAAC,EAAE;oCACnC,2BAA2B;oCAC3B,IAAI,CAAC,SAAS,EAAE;wCACZ,SAAG,CACC,iBAAiB,EACjB,0EACI,UAAU,CAAC,MAAM,gBACV,IAAI,CAAC,SAAS,CAAC,uBAAuB,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAC,CAAG,CAC5E,CAAC;wCACF,sBAAO,UAAU,EAAE,EAAC;qCACvB;oCACD,mCAAmC;iCACtC;gCAED,sBAAO,IAAI,EAAC;;;qBACf,CAAC;gBAEI,iBAAiB,GAAG,UAAC,WAAmB;oBAC1C,IAAM,WAAW,GAAG,EAAE,WAAW,CAAC;oBAElC,IAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC;oBAEvC,IAAI,iBAAO,CAAC,aAAa,CAAC,EAAE;wBACxB,SAAG,CAAC,mBAAmB,EAAE,wBAAwB,CAAC,CAAC;wBACnD,OAAO,UAAU,EAAE,CAAC;qBACvB;oBAED,6BAA6B;oBAC7B,IAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;oBAE5C,IAAI,iBAAO,CAAC,UAAU,CAAC,EAAE;wBACrB,SAAG,CAAC,mBAAmB,EAAE,kCAAkC,CAAC,CAAC;wBAC7D,OAAO,UAAU,EAAE,CAAC;qBACvB;oBAEM,IAAA,0BAAM,EAAE,sBAAI,CAAe;oBAElC,wDAAwD;oBACxD,IAAM,YAAY,GAAa,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;oBAEzD,IAAM,IAAI,GAAG,UAAU,CAAC,UAAU,CAAC;oBAEnC,IAAI,iBAAO,CAAC,IAAI,CAAC,EAAE;wBACf,SAAG,CAAC,mBAAmB,EAAE,0BAA0B,CAAC,CAAC;wBACrD,OAAO,UAAU,EAAE,CAAC;qBACvB;oBAED,oCAAoC;oBACpC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,yBACxB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,KAC5C,QAAQ,EAAE,WAAW,EACrB,MAAM,QAAA,EACN,WAAW,EAAE,eAAe,EAC5B,iBAAiB,EAAE,UAAU,GAChC,CAAC;oBAEF,cAAc;oBACd,EAAE,CAAC,UAAU,CACT,WAAW,EACX,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,EACpC,YAAY,+BAAC,UAAU,CAAC,MAAM,GAAK,IAAI,GAC1C,CAAC;oBAEF,kCAAkC;oBAClC,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC;oBAC5B,EAAE,CAAC,gBAAgB,EAAE,CAAC,CAAC,iBAAiB;oBAExC,SAAG,CACC,mBAAmB,EACnB,uCAAqC,WAAW,qBAAgB,WAAW,kBAAa,IAAI,CAAC,QAAQ,gBAAW,MAAM,cAAS,IAAM,CACxI,CAAC;oBACF,OAAO,OAAO,EAAE,CAAC;gBACrB,CAAC,CAAC;gBAsDF,GAAG,EAAE,CAAC;;;aACT,CAAC;QAvgBE,IAAM,IAAI,GAAG,IAAI,CAAC;QAElB,iCAAiC;QACjC,UAAU,CAAC,EAAE,CAAC,mBAAU,CAAC,SAAS,EAAE;;gBAChC,IAAI,CAAC,IAAI,EAAE,CAAC;;;aACf,CAAC,CAAC;QAEH,UAAU,CAAC,IAAI,CAAC,mBAAU,CAAC,IAAI,CAAC,CAAC,CAAC,kBAAkB;IACxD,CAAC;IAbD,sBAAkB,kBAAQ;aAA1B;YACI,OAAO,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE,CAAC,CAAC;QAC3D,CAAC;;;OAAA;IA2gBL,aAAC;AAAD,CAAC,AAhjBD,IAgjBC;AAhjBY,wBAAM;AAkjBnB,kBAAe,MAAM,CAAC","sourcesContent":["import IB from '@stoqey/ib';\nimport isEmpty from 'lodash/isEmpty';\nimport compact from 'lodash/compact';\nimport {intervalCollection} from '@stoqey/timeout-manager';\nimport {\n    ORDER,\n    OrderState,\n    CreateSale,\n    OrderWithContract,\n    OrderStatus,\n    OrderStatusType,\n    OrderStock,\n} from './orders.interfaces';\n\nimport {publishDataToTopic, IbkrEvents, IBKREVENTS} from '../events';\nimport IBKRConnection from '../connection/IBKRConnection';\n\nimport {Portfolios} from '../portfolios';\nimport {log, verbose} from '../log';\n\nconst ibkrEvents = IbkrEvents.Instance;\n\n// Place Order + Cancel Order\n// Get Filled open orders\n\ninterface SymbolTickerOrder {\n    tickerId: number;\n    orderPermId: number; // for reference when closing it\n    symbol: string;\n    stockOrderRequest: OrderStock;\n    orderStatus?: OrderStatusType;\n}\n\nexport class Orders {\n    ib: IB = null;\n\n    // StockOrders\n    tickerId = 0;\n    processing = false;\n\n    /**\n     * Orders to be taken from nextValidId\n     * These are always deleted after order is submitted to IB\n     */\n    stockOrders: OrderStock[] = [];\n\n    timeoutRetries: {[x: string]: string[]} = {};\n\n    /**\n     * A ledger of orders that are being executed,\n     * This is to avoid duplicate orders\n     * @unique\n     * new order overrides old one\n     * only filled, canceled, error orders can be overridden\n     */\n    symbolsTickerOrder: {[x: string]: SymbolTickerOrder} = {};\n\n    /**\n     * Redundant orderIdNext recorded\n     */\n    orderIdNext: number = null;\n\n    // OPEN ORDERS\n    public openOrders: {[x: string]: OrderWithContract} = {};\n    public receivedOrders = false; // stopper\n\n    private static _instance: Orders;\n\n    public static get Instance(): Orders {\n        return this._instance || (this._instance = new this());\n    }\n\n    private constructor() {\n        const self = this;\n\n        // only when connected createSale\n        ibkrEvents.on(IBKREVENTS.CONNECTED, async () => {\n            self.init();\n        });\n\n        ibkrEvents.emit(IBKREVENTS.PING); // ping connection\n    }\n\n    /**\n     * init\n     */\n    public init = async (): Promise<void> => {\n        const self = this;\n\n        if (!self.ib) {\n            const ib = IBKRConnection.Instance.getIBKR();\n            self.ib = ib;\n\n            ib.on('openOrderEnd', () => {\n                // Initialise OrderTrader\n                // OrderTrade.Instance.init();\n\n                const openOrders = Object.keys(self.openOrders).map((key) => self.openOrders[key]);\n\n                publishDataToTopic({\n                    topic: IBKREVENTS.OPEN_ORDERS,\n                    data: openOrders,\n                });\n            });\n\n            ib.on(\n                'orderStatus',\n                (\n                    id,\n                    status,\n                    filled,\n                    remaining,\n                    avgFillPrice,\n                    permId,\n                    parentId,\n                    lastFillPrice,\n                    clientId,\n                    whyHeld\n                ) => {\n                    const currentOrder = self.openOrders[id];\n\n                    const orderStatus: OrderStatus = {\n                        status,\n                        filled,\n                        remaining,\n                        avgFillPrice,\n                        permId,\n                        parentId,\n                        lastFillPrice,\n                        clientId,\n                        whyHeld,\n                    };\n\n                    publishDataToTopic({\n                        topic: IBKREVENTS.ORDER_STATUS, //push to topic below,\n                        data: {\n                            order: currentOrder,\n                            orderStatus,\n                        },\n                    });\n\n                    verbose(\n                        `Orders > orderStatus ${currentOrder && currentOrder.symbol}`,\n                        JSON.stringify({\n                            id,\n                            status,\n                            filled,\n                            remaining,\n                            symbol: currentOrder && currentOrder.symbol,\n                        })\n                    );\n                }\n            );\n\n            ib.on('openOrder', function (orderId, contract, order: ORDER, orderState: OrderState) {\n                // 1. Update OpenOrders\n                // Orders that need to be filled\n                // -----------------------------------------------------------------------------------\n                self.receivedOrders = true;\n\n                const openOrders = self.openOrders;\n\n                self.openOrders = {\n                    ...openOrders,\n                    [orderId]: {\n                        ...((openOrders && openOrders[orderId]) || null),\n\n                        // OrderId + orderState\n                        orderId,\n                        orderState,\n\n                        // Add order\n                        ...order,\n                        // Add contract\n                        ...contract,\n                    },\n                };\n                //  Delete order from openOrders list\n                if (orderState.status === 'Filled') {\n                    log(\n                        `Filled -----> DELETE FROM OPEN ORDERS -------> symbol=${\n                            contract && contract.symbol\n                        }`\n                    );\n                    delete self.openOrders[orderId];\n                }\n\n                //  Delete order from openOrders list\n                if (['PendingCancel', 'Cancelled', 'ApiCancelled'].includes(orderState.status)) {\n                    log(\n                        `${orderState.status} -----> DELETE FROM OPEN ORDERS -------> ${\n                            contract && contract.symbol\n                        }`\n                    );\n                    delete self.openOrders[orderId];\n                }\n\n                const openOrdersArr = Object.keys(self.openOrders).map(\n                    (key) => self.openOrders[key]\n                );\n                log(`OPEN ORDERS ${openOrdersArr && openOrdersArr.length}`);\n                // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n                // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n                // 2. Update OrderStocks\n                // Orders requests to send to transmit\n                // Using ticker Ids\n                // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n                const allTickerOrder: SymbolTickerOrder[] = Object.keys(\n                    self.symbolsTickerOrder\n                ).map((key) => self.symbolsTickerOrder[key]);\n\n                const thisOrderTicker = allTickerOrder.find(\n                    (tickerOrder) => tickerOrder.tickerId === orderId\n                );\n\n                // Add permId to orderTickObject\n                if (!isEmpty(thisOrderTicker)) {\n                    // update this symbolTickerOrder\n                    self.symbolsTickerOrder[thisOrderTicker.symbol] = {\n                        ...(self.symbolsTickerOrder[thisOrderTicker.symbol] || null),\n                        orderPermId: order.permId,\n                        symbol: thisOrderTicker.symbol,\n                        orderStatus: orderState.status, // update order state\n                    };\n\n                    const updatedSymbolTicker = self.symbolsTickerOrder[thisOrderTicker.symbol];\n\n                    // create sale if order is filled\n                    if (orderState.status === 'Filled') {\n                        // Order is filled we can record it\n                        // Check if we can create new trade\n                        // on if stockOrderRequest is present\n                        // that.symbolsTickerOrder[thisOrderTicker.symbol]\n                        if (!isEmpty(updatedSymbolTicker.stockOrderRequest)) {\n                            const {stockOrderRequest} = updatedSymbolTicker;\n                            const {exitTrade, exitParams, symbol, capital} = stockOrderRequest;\n\n                            const dataSaleSymbolOrder: OrderWithContract = {\n                                ...order,\n                                ...contract,\n                                orderState,\n                                orderId,\n                            };\n\n                            if (exitTrade) {\n                                const {exitPrice, exitTime, entryTime, entryPrice} = exitParams;\n                                // If this trade is for exiting then record the sale\n                                // create sale now\n                                const newSale: CreateSale = {\n                                    capital,\n                                    exitPrice,\n                                    exitTime,\n                                    entryTime,\n                                    entryPrice,\n                                    symbol,\n                                    profit: entryPrice - exitPrice,\n                                };\n\n                                log(\n                                    `AccountOrderStock.openOrder`,\n                                    `FILLED, TO CREATE SALE -> ${contract.symbol} ${order.action} ${order.totalQuantity}  ${orderState.status}`\n                                );\n\n                                return publishDataToTopic({\n                                    topic: IBKREVENTS.ORDER_FILLED,\n                                    data: {sale: newSale, order: dataSaleSymbolOrder},\n                                });\n                            }\n\n                            log(\n                                `AccountOrderStock.openOrder`,\n                                `FILLED, but no sale created -> ${contract.symbol} ${order.action} ${order.totalQuantity}  ${orderState.status}`\n                            );\n\n                            publishDataToTopic({\n                                topic: IBKREVENTS.ORDER_FILLED,\n                                data: {sale: null, order: dataSaleSymbolOrder},\n                            });\n                        }\n                    }\n                }\n            });\n\n            // placeOrder event\n            ibkrEvents.on(\n                IBKREVENTS.PLACE_ORDER,\n                async ({stockOrder}: {stockOrder: OrderStock}) => {\n                    await self.placeOrder(stockOrder);\n                }\n            );\n        }\n    };\n\n    public getOpenOrders = async (timeout?: number): Promise<OrderWithContract[]> => {\n        const self = this;\n\n        let openedOrders = {};\n\n        return new Promise((resolve) => {\n            let done = false;\n\n            // listen for account summary\n            const handleOpenOrders = (ordersData) => {\n                if (!done) {\n                    self.ib.off('openOrder', handleOpenOrders);\n                    done = true;\n                    resolve(ordersData);\n                }\n            };\n\n            self.ib.once('openOrderEnd', () => {\n                const openOrders = Object.keys(openedOrders).map((key) => openedOrders[key]);\n                handleOpenOrders(openOrders);\n            });\n\n            self.ib.on('openOrder', function (\n                orderId,\n                contract,\n                order: ORDER,\n                orderState: OrderState\n            ) {\n                // Only check pending orders\n                if (\n                    ['PendingSubmit', 'PreSubmitted', 'Submitted'].includes(\n                        orderState && orderState.status\n                    )\n                ) {\n                    openedOrders = {\n                        ...openedOrders,\n                        [orderId]: {\n                            ...((openedOrders && openedOrders[orderId]) || null),\n\n                            // OrderId + orderState\n                            orderId,\n                            orderState,\n\n                            // Add order\n                            ...order,\n                            // Add contract\n                            ...contract,\n                        },\n                    };\n                }\n            });\n\n            self.ib.reqAllOpenOrders(); // refresh orders\n\n            return setTimeout(handleOpenOrders, timeout || 6000);\n        });\n    };\n\n    public isActive = (): boolean => {\n        return this.receivedOrders;\n    };\n\n    /**\n     * Place Order\n     * Order is added to queue if is already processing one order\n     * @stockOrder\n     * @options ? {}\n     * @when Until IBKR releases a new OrderId, then order is placed and process can pick other orders\n     */\n    public placeOrder = async (\n        stockOrder: OrderStock,\n        options?: {retryCounts?: number; retryTime?: number}\n    ): Promise<void | any> => {\n        const self = this;\n        const ib = self.ib;\n\n        const {exitTrade, symbol} = stockOrder;\n\n        const numberOfRetries = (options && options.retryCounts) || 3;\n        const retryDelayTime = (options && options.retryTime) || 2000;\n\n        const success = (): void => {\n            ib.off('nextValidId', handleOrderIdNext);\n            self.processing = false; // reset processing\n            return;\n        };\n\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const erroredOut = (error?: Error): void => {\n            ib.off('nextValidId', handleOrderIdNext);\n            self.processing = false; // reset processing\n            return;\n        };\n\n        const checkPending = async (): Promise<void | boolean> => {\n            // -1 Validate size\n            const orderSize = stockOrder.size;\n\n            if (Number.isNaN(orderSize)) {\n                log(\n                    'placingOrderNow.checkPending',\n                    `*********************** orderSize is NaN size=${orderSize} action=${stockOrder.action} symbol=${symbol}`\n                );\n                return erroredOut();\n            }\n\n            // 0. Pending orders\n            // Check active tickerSymbols\n            const pendingOrders = self.symbolsTickerOrder[symbol];\n            const pendingOrderStatus = pendingOrders && pendingOrders.orderStatus;\n            const isPending = ['PreSubmitted', 'Submitted', 'PendingSubmit'].includes(\n                pendingOrderStatus\n            );\n\n            if (isPending) {\n                log(\n                    'placingOrderNow',\n                    `*********************** Order is already being processed for ${\n                        stockOrder.action\n                    } symbol=${symbol} pendingOrderStatus=${\n                        pendingOrderStatus || 'NONE'\n                    } isPending=${isPending}`\n                );\n                return erroredOut();\n            }\n\n            // 1. Check existing open orders\n            const checkExistingOrders = await self.getOpenOrders();\n\n            log(\n                'placingOrderNow',\n                `Existing orders in queue -> ${checkExistingOrders.map((i) => i.symbol)}`\n            );\n\n            if (!isEmpty(checkExistingOrders)) {\n                // check if we have the same order from here\n                const findMatchingAction = checkExistingOrders.filter(\n                    (exi) => exi.action === stockOrder.action && exi.symbol === stockOrder.symbol\n                );\n\n                if (!isEmpty(findMatchingAction)) {\n                    log(\n                        'placingOrderNow',\n                        `Order already exist for ${stockOrder.action}, ${findMatchingAction[0].symbol} ->  @${stockOrder.parameters[0]}`\n                    );\n                    return erroredOut();\n                }\n            }\n\n            // 2. Check existing portfolios\n            let checkExistingPositions = await Portfolios.Instance.getPortfolios();\n            checkExistingPositions = !isEmpty(checkExistingPositions) ? checkExistingPositions : [];\n\n            verbose(\n                'placingOrderNow',\n                `Existing portfolios -> ${JSON.stringify(\n                    checkExistingPositions && checkExistingPositions.map((i) => i.symbol)\n                )}`\n            );\n\n            const foundExistingPortfolios = !isEmpty(checkExistingPositions)\n                ? checkExistingPositions.filter((exi) => exi.symbol === stockOrder.symbol)\n                : [];\n\n            verbose(\n                'placingOrderNow',\n                `foundExistingPortfolios -> ${JSON.stringify(\n                    foundExistingPortfolios.map((i) => i.symbol)\n                )}`\n            );\n\n            if (!isEmpty(foundExistingPortfolios)) {\n                // Only if this is not exit\n                if (!exitTrade) {\n                    log(\n                        'placingOrderNow',\n                        `*********************** Portfolio already exist and has position for ${\n                            stockOrder.action\n                        }, order=${JSON.stringify(foundExistingPortfolios.map((i) => i.symbol))}`\n                    );\n                    return erroredOut();\n                }\n                // Else existing trades are allowed\n            }\n\n            return true;\n        };\n\n        const handleOrderIdNext = (orderIdNext: number) => {\n            const tickerToUse = ++orderIdNext;\n\n            const currentOrders = self.stockOrders;\n\n            if (isEmpty(currentOrders)) {\n                log('handleOrderIdNext', `Stock Orders are empty`);\n                return erroredOut();\n            }\n\n            // get order by it's tickerId\n            const stockOrder = self.stockOrders.shift();\n\n            if (isEmpty(stockOrder)) {\n                log('handleOrderIdNext', `First Stock Orders Item is empty`);\n                return erroredOut();\n            }\n\n            const {symbol, size} = stockOrder;\n\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            const orderCommand: Function = ib.order[stockOrder.type];\n\n            const args = stockOrder.parameters;\n\n            if (isEmpty(args)) {\n                log('handleOrderIdNext', `Arguments cannot be null`);\n                return erroredOut();\n            }\n\n            // Just save tickerId and stockOrder\n            self.symbolsTickerOrder[symbol] = {\n                ...(self.symbolsTickerOrder[symbol] || null),\n                tickerId: tickerToUse,\n                symbol,\n                orderStatus: 'PendingSubmit',\n                stockOrderRequest: stockOrder, // for reference when closing trade,\n            };\n\n            // Place order\n            ib.placeOrder(\n                tickerToUse,\n                ib.contract.stock(stockOrder.symbol),\n                orderCommand(stockOrder.action, ...args)\n            );\n\n            // self.orderIdNext = tickerToUse;\n            self.tickerId = tickerToUse;\n            ib.reqAllOpenOrders(); // refresh orders\n\n            log(\n                'handleOrderIdNext',\n                `Placing order for ... tickerToUse=${tickerToUse} orderIdNext=${orderIdNext} tickerId=${self.tickerId} symbol=${symbol} size=${size}`\n            );\n            return success();\n        };\n\n        function placingOrderNow(): void {\n            if (isEmpty(stockOrder.symbol)) {\n                return erroredOut(new Error('Please enter order'));\n            }\n\n            self.stockOrders = [...self.stockOrders, stockOrder];\n            self.ib.reqIds(++self.orderIdNext);\n            verbose(\n                'placingOrderNow',\n                `Order > placeOrder -> tickerId=${self.tickerId} symbol=${stockOrder.symbol}`\n            );\n        }\n\n        async function run(): Promise<void> {\n            const canProceed = await checkPending();\n\n            if (canProceed === true) {\n                // can proceed\n                // 1. Processing, or recursive\n                if (self.processing) {\n                    const handleRecursive = setInterval(() => {\n                        console.log('retry in --------------------->', symbol);\n                        self.placeOrder(stockOrder);\n                    }, 2000);\n\n                    const handlerId = intervalCollection.get(handleRecursive);\n\n                    // save the symbol with it's timeout\n                    self.timeoutRetries[stockOrder.symbol] = compact([\n                        ...(self.timeoutRetries[stockOrder.symbol] || []),\n                        handlerId && handlerId.uuid,\n                    ]);\n\n                    setTimeout(() => {\n                        intervalCollection.remove(handleRecursive);\n                    }, numberOfRetries * retryDelayTime);\n                    return;\n                }\n\n                // Clear all by this symbol\n                (self.timeoutRetries[stockOrder.symbol] || []).forEach((uuid) => {\n                    intervalCollection.removeByUuid(uuid);\n                });\n\n                // Start -----------------------------\n                self.processing = true;\n\n                ib.on('nextValidId', handleOrderIdNext); // start envs\n                return placingOrderNow();\n            }\n        }\n\n        run();\n    };\n}\n\nexport default Orders;\n"]}